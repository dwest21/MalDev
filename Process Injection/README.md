# Purpose

For this small project, I made a process injection malware. The whole point of this was to increase my level of understanding on how malware interacts with Windows APIs, and also to increase my investigative skills for process injection. A large part of what I coded was through external research (reading MSDN docs, YUCK!) and watching [this](https://www.youtube.com/watch?v=A6EKDAKBXPs) video. 

While I am not **remotely** close to an expert, I did learn a lot of things about the Windows environment and APIs, so I'll write them down here. It's also probably worth nothing that the shellcode provided in this project was generated using MSFVenom, so it's heavily signatured and will likely get detected before even running the code. 

## Windows APIs

When I first started, I knew in a very broad sense of how Windows APIs work, but I always wondered how an attacker could take advantage of those. I mean, they were always just sitting there for anyone to use right? Well, after seeing some live malware samples that utilized process injection, I began to Google what APIs were used in practice. 

Immediately, I found that there were two main libraries that you can use for this: **ntdll.dll** and **kernel32.dll**. The difference between the two is that **ntdll.dll** is a lower-level library, and it contains something called a "syscall"; this makes ntdll very desirable for threat actors, and because of that, common EDR and AV tools monitor this library using API hooks (which we're going to explore whenever I make a writeup on direct and indirect syscalls). Meanwhile, **kernel32.dll** is essentially a wrapper for ntdll.dll, and makes it nice and easy to use Winapi. The library that I used for this rudimentary project was kernel32.dll because, as I said previously, it makes interacting with Windows APIs much less aggravating. 

I also want to mention this beautiful [website](https://malapi.io/) because it has helped a ton in both my malware analysis and malware development journey for understanding malware at a deeper level.

## Process Injection

In order to inject into another process using Windows APIs, you need to follow this generalized workflow: 

1. Open target process
2. Allocate virtual memory in target process
3. Write shellcode into virtual memory space in target process
4. Create a thread to execute target process memory

It seems easy enough, right? Well, kind of. Initially I had to grab the snapshot of current processes in memory using CreateToolhelp32Snapshot(), and had to find my target process by iterating through them until I found the process name. Now, there is a chance that there's a duplicate process with the same name, so I just grab the first instance; for this instance we don't really need anything more because this can be thought of as a personal Proof-of-Concept project. After I find the process name, I allocated the virtual memory and wrote it to the process using VirtualAllocEx() and WriteProcessMemory(), respectively. Lastly, I created a thread to actually execute the shellcode that was injected. Boom! We've now written a piece of malware that injects shellcode into a remote process, super fun to learn! 

## Shellcode

As mentioned in the intro, the shellcode that I injected was generated by MSFVenom. This is fine for the purposes of learning malware development and getting things to work, however, if I want to actually delve into red team activities this will simply not do. So, in a commented line, you'll see that I generated my own shellcode. It does NOT work when it's injected into another process, however, the executable comprised of that shellcode works so I'm not sure what went wrong. 

The way that I generated the shellcode was by manipulating the compilation process (which I learned more about through this [red team article](https://www.ired.team/offensive-security/code-injection-process-injection/writing-and-compiling-shellcode-in-c), that was based on this super cool [research paper](https://github.com/vxunderground/VXUG-Papers/blob/main/From%20a%20C%20project%20through%20assembly%20to%20shellcode.pdf) by hasherezade, who is the creator of PEBear and other cool forensics tools). 

### C Code

This process works by writing "position-independent code". We need to do this because we won't have access to the relocation table that's called at runtime, so we only call addresses relative to our current section. Then, in order to get access to the APIs we need, we need to use the Process Environment Block (PEB) to resolve some APIs for us. That header file was included in both links previously mentioned in this section. The PEB is used to fetch Kernel32.dll and from there, we can load whatever other lilbrary we need. The article by hasherezade goes into much deeper detail, however, all that's needed for this explanation is that the shellcode was generated to be position-independent, and doesn't rely on any form of import table because that's resolved using another processes' PEB. Strings and other structures are also defined within main as arrays, so we can reference their indices in the assembly portion of this walkthrough. 

### Assembly

In order to get the assembly from the C code, we have to manipulate the compilation process. The compilation workflow is as follows (shown in the research article): 

![image](https://github.com/user-attachments/assets/6c3e2f88-b8e7-4178-8171-43f17c1975d8)

After looking at this diagram, we see that we just need to skip the linker, as this would give us the assembly code. So that's exactly what we do. Now, it depends on what compiler you're using, however, I used CL because it was readily available to me within Visual Studio. The command line provided is ```cl.exe /c /FA /GS- "C:\PATH\TO\C_PROGRAM.c"```. Now that we have assembly, we have to make some modifications to it by removing any external references, and making sure there are no syntax errors provided. This includes aligning the RSP register to 64-bits, as well as various other small assembly things. Provided down below is how the process works for moving from assembly into a binary:

![image](https://github.com/user-attachments/assets/e15f91da-7dee-4624-b6a2-87745b7c4a46)


I used MASM for this, as again, it was readily available within Visual Studio. This whole process took me about a full day to finally get the shellcode to compile from assembly (ugh). The final step is to put the binary into a hex editor like HxD and copy the hex values from the .text/.code section (as those are the actual executable machine instructions), and that would be your shellcode!

## Takeaways

I learned a lot through this process, including how to interact with Windows APIs and a deepeer understanding of the compilation process. This information is invaluable since Windows is the Operating System with the highest amount of attacks (followed by Android), so gearing myself into the **red team** mindset allowed me a deeper understanding of how to handle situations from a *blue team* perspective and gain more knowledge for future incidents and investigations.  This project also lead me down a rabbit hole by showing me lots of neat things you can do with Windows APIs, and I can't wait to show more of what I learn as I go along!
