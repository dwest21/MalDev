# Purpose

For this small project, I made a process injection malware. The whole point of this was to increase my level of understanding on how malware interacts with Windows APIs, and also to increase my investigative skills for process injection. A large part of what I coded was through external research (reading MSDN docs, YUCK!) and watching [this](https://www.youtube.com/watch?v=A6EKDAKBXPs) video. 

While I am not **remotely** close to an expert, I did learn a lot of things about the Windows environment and APIs, so I'll write them down here. It's also probably worth nothing that the shellcode provided in this project was generated using MSFVenom, so it's heavily signatured and will likely get detected before even running the code. 

## Windows APIs

When I first started, I knew in a very broad sense of how Windows APIs work, but I always wondered how an attacker could take advantage of those. I mean, they were always just sitting there for anyone to use right? Well, after seeing some live malware samples that utilized process injection, I began to Google what APIs were used in practice. 

Immediately, I found that there were two main libraries that you can use for this: **ntdll.dll** and **kernel32.dll**. The difference between the two is that **ntdll.dll** is a lower-level library, and it contains something called a "syscall"; this makes ntdll very desirable for threat actors, and because of that, common EDR and AV tools monitor this library using API hooks (which we're going to explore whenever I make a writeup on direct and indirect syscalls). Meanwhile, **kernel32.dll** is essentially a wrapper for ntdll.dll, and makes it nice and easy to use Winapi. The library that I used for this rudimentary project was kernel32.dll because, as I said previously, it makes interacting with Windows APIs much less aggravating. 

I also want to mention this beautiful [website](https://malapi.io/) because it has helped a ton in both my malware analysis and malware development journey for understanding malware at a deeper level.

## Process Injection

In order to inject into another process using Windows APIs, you need to follow this generalized workflow: 

1. Open target process
2. Allocate virtual memory in target process
3. Write shellcode into virtual memory space in target process
4. Create a thread to execute target process memory

It seems easy enough, right? Well, kind of. Initially I had to grab the snapshot of current processes in memory using CreateToolhelp32Snapshot(), and had to find my target process by iterating through them until I found the process name. Now, there is a chance that there's a duplicate process with the same name, so I just grab the first instance; for this instance we don't really need anything more because this can be thought of as a personal Proof-of-Concept project. After I find the process name, I allocated the virtual memory and wrote it to the process using VirtualAllocEx() and WriteProcessMemory(), respectively. Lastly, I created a thread to actually execute the shellcode that was injected. Boom! We've now written a piece of malware that injects shellcode into a remote process, super fun to learn! 

## Shellcode

As mentioned in the intro, the shellcode that I injected was generated by MSFVenom. This is fine for the purposes of learning malware development and getting things to work, however, if I want to actually delve into red team activities this will simply not do. So, in a commented line, you'll see that I generated my own shellcode. It does NOT work when it's injected into another process, however, the executable comprised of that shellcode works so I'm not sure what went wrong. 

The way that I generated the shellcode was by manipulating the compilation process (which I learned more about through this [red team article](https://www.ired.team/offensive-security/code-injection-process-injection/writing-and-compiling-shellcode-in-c), that was based on this super cool [research paper](https://github.com/vxunderground/VXUG-Papers/blob/main/From%20a%20C%20project%20through%20assembly%20to%20shellcode.pdf) by hasherezade, who is the creator of PEBear and other cool forensics tools). 

This process works by writing "position-independent code". We need to do this because the relocation table is going to be different from the shellcode we write to the process we are going to inject into, so we resolve addresses without the relocation table and by using the image base. 
